/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct wiringPiNodeStruct {
    pub pinBase: ::libc::c_int,
    pub pinMax: ::libc::c_int,
    pub fd: ::libc::c_int,
    pub data0: ::libc::c_uint,
    pub data1: ::libc::c_uint,
    pub data2: ::libc::c_uint,
    pub data3: ::libc::c_uint,
    pub pinMode: ::std::option::Option<unsafe extern "C" fn(node:
                                                                *mut wiringPiNodeStruct,
                                                            pin:
                                                                ::libc::c_int,
                                                            mode:
                                                                ::libc::c_int)>,
    pub pullUpDnControl: ::std::option::Option<unsafe extern "C" fn(node:
                                                                        *mut wiringPiNodeStruct,
                                                                    pin:
                                                                        ::libc::c_int,
                                                                    mode:
                                                                        ::libc::c_int)>,
    pub digitalRead: ::std::option::Option<unsafe extern "C" fn(node:
                                                                    *mut wiringPiNodeStruct,
                                                                pin:
                                                                    ::libc::c_int)
                                               -> ::libc::c_int>,
    pub digitalWrite: ::std::option::Option<unsafe extern "C" fn(node:
                                                                     *mut wiringPiNodeStruct,
                                                                 pin:
                                                                     ::libc::c_int,
                                                                 value:
                                                                     ::libc::c_int)>,
    pub pwmWrite: ::std::option::Option<unsafe extern "C" fn(node:
                                                                 *mut wiringPiNodeStruct,
                                                             pin:
                                                                 ::libc::c_int,
                                                             value:
                                                                 ::libc::c_int)>,
    pub analogRead: ::std::option::Option<unsafe extern "C" fn(node:
                                                                   *mut wiringPiNodeStruct,
                                                               pin:
                                                                   ::libc::c_int)
                                              -> ::libc::c_int>,
    pub analogWrite: ::std::option::Option<unsafe extern "C" fn(node:
                                                                    *mut wiringPiNodeStruct,
                                                                pin:
                                                                    ::libc::c_int,
                                                                value:
                                                                    ::libc::c_int)>,
    pub next: *mut wiringPiNodeStruct,
}
impl ::std::default::Default for wiringPiNodeStruct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

use std::fmt::Write;

macro_rules! binding_functions {
    ( $( pub fn $name:ident ( $( $arg_name:ident: $arg_type:ty ),* ) -> $return_type:ty ; $return_value:expr ; )* ) => {
        #[cfg(not(feature = "development"))]
        #[link(name = "wiringpi", kind = "static")]
        extern "C" {
            $(
                pub fn $name($($arg_name: $arg_type),*) -> $return_type;
            )*
        }

        $(
            #[cfg(feature = "development")]
            pub fn $name($($arg_name: $arg_type),*) -> $return_type {
                let mut args = String::new();

                $(
                    if args.is_empty() {
                        write!(&mut args, "{:?}", $arg_name);
                    } else {
                        write!(&mut args, ", {:?}", $arg_name);
                    }
                )*

                if args.is_empty() {
                    println!("[wiringpi] `{}` called", stringify!($name));
                } else {
                    println!("[wiringpi] `{}` called with: {}", stringify!($name), args);
                }

                $return_value
            }
        )*
    };
}

binding_functions! {
    pub fn wiringPiSetup() -> ::libc::c_int; 0;
    pub fn wiringPiSetupSys() -> ::libc::c_int; 0;
    pub fn wiringPiSetupGpio() -> ::libc::c_int; 0;
    pub fn wiringPiSetupPhys() -> ::libc::c_int; 0;
    pub fn pinModeAlt(pin: ::libc::c_int, mode: ::libc::c_int) -> (); ();
    pub fn pinMode(pin: ::libc::c_int, mode: ::libc::c_int) -> (); ();
    pub fn pullUpDnControl(pin: ::libc::c_int, pud: ::libc::c_int) -> (); ();
    pub fn digitalRead(pin: ::libc::c_int) -> ::libc::c_int; 0;
    pub fn digitalWrite(pin: ::libc::c_int, value: ::libc::c_int) -> (); ();
    pub fn pwmWrite(pin: ::libc::c_int, value: ::libc::c_int) -> (); ();
    pub fn analogRead(pin: ::libc::c_int) -> ::libc::c_int; 0;
    pub fn analogWrite(pin: ::libc::c_int, value: ::libc::c_int) -> (); ();
    pub fn wiringPiSetupPiFace() -> ::libc::c_int; 0;
    pub fn wiringPiSetupPiFaceForGpioProg() -> ::libc::c_int; 0;
    pub fn piBoardRev() -> ::libc::c_int; 0;
    pub fn piBoardId(model: *mut ::libc::c_int, rev: *mut ::libc::c_int,
                     mem: *mut ::libc::c_int, maker: *mut ::libc::c_int,
                     overVolted: *mut ::libc::c_int) -> (); ();
    pub fn wpiPinToGpio(wpiPin: ::libc::c_int) -> ::libc::c_int; 0;
    pub fn physPinToGpio(physPin: ::libc::c_int) -> ::libc::c_int; 0;
    pub fn setPadDrive(group: ::libc::c_int, value: ::libc::c_int) -> (); ();
    pub fn getAlt(pin: ::libc::c_int) -> ::libc::c_int; 0;
    pub fn pwmToneWrite(pin: ::libc::c_int, freq: ::libc::c_int) -> (); ();
    pub fn digitalWriteByte(value: ::libc::c_int) -> (); ();
    pub fn digitalReadByte() -> ::libc::c_uint; 0;
    pub fn pwmSetMode(mode: ::libc::c_int) -> (); ();
    pub fn pwmSetRange(range: ::libc::c_uint) -> (); ();
    pub fn pwmSetClock(divisor: ::libc::c_int) -> (); ();
    pub fn gpioClockSet(pin: ::libc::c_int, freq: ::libc::c_int) -> (); ();
    pub fn waitForInterrupt(pin: ::libc::c_int, mS: ::libc::c_int)
     -> ::libc::c_int; 0;
    pub fn wiringPiISR(pin: ::libc::c_int, mode: ::libc::c_int,
                       function: ::std::option::Option<extern "C" fn()>)
     -> ::libc::c_int; 0;
    pub fn piThreadCreate(fn_:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::libc::c_void)
                                                        ->
                                                            *mut ::libc::c_void>)
     -> ::libc::c_int; 0;
    pub fn piLock(key: ::libc::c_int) -> (); ();
    pub fn piUnlock(key: ::libc::c_int) -> (); ();
    pub fn piHiPri(pri: ::libc::c_int) -> ::libc::c_int; 0;
    pub fn delay(howLong: ::libc::c_uint) -> (); ();
    pub fn delayMicroseconds(howLong: ::libc::c_uint) -> (); ();
    pub fn millis() -> ::libc::c_uint; 0;
    pub fn micros() -> ::libc::c_uint; 0;
    pub fn softPwmCreate(pin: ::libc::c_int, value: ::libc::c_int,
                         range: ::libc::c_int) -> ::libc::c_int; 0;
    pub fn softPwmWrite(pin: ::libc::c_int, value: ::libc::c_int) -> (); ();
    pub fn softPwmStop(pin: ::libc::c_int) -> (); ();
}
